<!--MySQL 8.0+ (InnoDB, utf8mb4)-->

<!--        Notes:-->
<!--        We use a composite foreign key (question.id, question.correct_option_id) → (option.question_id, option.id) to guarantee the correct option belongs to the same question.-->
<!--        Insert flow: insert question (without correct_option_id), insert its options, then update correct_option_id.-->
<!--        &#45;&#45; Schema create table trivia_category ( id bigint unsigned primary key auto_increment, name varchar(255) not null unique ) engine=InnoDB default charset=utf8mb4 collate=utf8mb4_0900_ai_ci;-->

<!--        create table trivia_question ( id bigint unsigned primary key auto_increment, category_id bigint unsigned null, question_text text not null, explanation text null, difficulty enum('easy','medium','hard') not null default 'easy', image_url text null, correct_option_id bigint unsigned null, created_at timestamp not null default current_timestamp, constraint fk_question_category foreign key (category_id) references trivia_category(id) ) engine=InnoDB default charset=utf8mb4 collate=utf8mb4_0900_ai_ci;-->

<!--        create table trivia_option ( id bigint unsigned primary key auto_increment, question_id bigint unsigned not null, option_text text not null, position int not null, &#45;&#45; 1..4 constraint fk_option_question foreign key (question_id) references trivia_question(id) on delete cascade, constraint uq_option_question_position unique (question_id, position), &#45;&#45; Needed to support the composite FK from trivia_question constraint uq_option_question_id unique (question_id, id) ) engine=InnoDB default charset=utf8mb4 collate=utf8mb4_0900_ai_ci;-->

<!--        &#45;&#45; Ensure the correct_option_id (if set) points to an option of the same question alter table trivia_question add constraint fk_question_correct_option foreign key (id, correct_option_id) references trivia_option (question_id, id);-->

<!--        &#45;&#45; Example insert (transaction recommended) start transaction;-->

<!--        insert into trivia_question (category_id, question_text, difficulty, explanation) values (null, 'What is the capital of France?', 'easy', 'Paris is the capital and most populous city of France.');-->

<!--        set @qid = last_insert_id();-->

<!--        insert into trivia_option (question_id, option_text, position) values (@qid, 'Paris', 1), (@qid, 'Lyon', 2), (@qid, 'Marseille', 3), (@qid, 'Nice', 4);-->

<!--        &#45;&#45; Pick correct option id select id into @opt_correct from trivia_option where question_id = @qid and position = 1;-->

<!--        update trivia_question set correct_option_id = @opt_correct where id = @qid;-->

<!--        commit;-->

<!--        &#45;&#45; Fetch a question with shuffled options select q.id as question_id, q.question_text, o.id as option_id, o.option_text from trivia_question q join trivia_option o on o.question_id = q.id where q.id = @qid order by rand();-->

<!--        &#45;&#45; Check an answer (is selected option correct?) select (q.correct_option_id = :selected_option_id) as is_correct from trivia_question q where q.id = :qid;-->

<!--        &#45;&#45; Reveal explanation and correct answer after answering select q.explanation, co.option_text as correct_answer from trivia_question q join trivia_option co on co.id = q.correct_option_id where q.id = :qid;-->

<!--        &#45;&#45; Get 10 random questions in a category (simple approach) select id from trivia_question where category_id = :cat_id order by rand() limit 10;-->

<!--        PostgreSQL-->

<!--        Notes:-->
<!--        Same composite FK, but marked DEFERRABLE so you can set correct_option_id within the same transaction in any order (nice for bulk loads).-->
<!--        random() instead of RAND().-->
<!--        &#45;&#45; Schema create table trivia_category ( id bigserial primary key, name text not null unique );-->

<!--        create table trivia_question ( id bigserial primary key, category_id bigint references trivia_category(id), question_text text not null, explanation text, difficulty text not null check (difficulty in ('easy','medium','hard')), image_url text, correct_option_id bigint, created_at timestamptz not null default now() );-->

<!--        create table trivia_option ( id bigserial primary key, question_id bigint not null references trivia_question(id) on delete cascade, option_text text not null, position int not null, constraint uq_option_question_position unique (question_id, position), &#45;&#45; Needed for composite FK constraint uq_option_question_id unique (question_id, id) );-->

<!--        &#45;&#45; Ensure the correct option belongs to the same question (deferrable) alter table trivia_question add constraint fk_question_correct_option foreign key (id, correct_option_id) references trivia_option (question_id, id) deferrable initially deferred;-->

<!--        &#45;&#45; Example insert begin;-->

<!--        insert into trivia_question (category_id, question_text, difficulty, explanation) values (null, 'What is the capital of France?', 'easy', 'Paris is the capital and most populous city of France.') returning id into strict qid;-->

<!--        &#45;&#45; Or capture with a CTE: &#45;&#45; with q as ( &#45;&#45; insert into trivia_question (...) values (...) returning id &#45;&#45; ) &#45;&#45; insert options using (select id from q)-->

<!--        insert into trivia_option (question_id, option_text, position) values (qid, 'Paris', 1), (qid, 'Lyon', 2), (qid, 'Marseille', 3), (qid, 'Nice', 4) returning id, position;-->

<!--        &#45;&#45; Set correct option (works nicely because FK is deferrable) update trivia_question q set correct_option_id = o.id from trivia_option o where q.id = qid and o.question_id = qid and o.position = 1;-->

<!--        commit;-->

<!--        &#45;&#45; Fetch with shuffled options select q.id as question_id, q.question_text, o.id as option_id, o.option_text from trivia_question q join trivia_option o on o.question_id = q.id where q.id = $1 order by random();-->

<!--        &#45;&#45; Check an answer select (q.correct_option_id = $2) as is_correct from trivia_question q where q.id = $1;-->

<!--        &#45;&#45; Reveal explanation and the correct answer select q.explanation, co.option_text as correct_answer from trivia_question q join trivia_option co on co.id = q.correct_option_id where q.id = $1;-->

<!--        &#45;&#45; 10 random questions in a category select id from trivia_question where category_id = $1 order by random() limit 10;-->

<!--        Practical tips-->

<!--        Don’t send correct_option_id to clients when serving the question.-->
<!--        For very large tables, avoid order by rand()/random(); instead pre-sample ids (e.g., pick random id ranges) or maintain a table of active question ids and sample from it.-->
<!--        If you need multiple correct answers later, move correctness to trivia_option (is_correct boolean) and drop the composite FK; add a partial unique index if you still want “at most one” correct answer per question.-->